"""
Streamlit Dashboard for Bank Check Prediction System

Simple dashboard for making predictions and viewing results.
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import json
from pathlib import Path
import sys
from datetime import datetime

# Add src to path for imports
sys.path.append(str(Path(__file__).parent.parent))

# Direct imports to avoid package complexity
from src.models.prediction_model import CheckPredictionModel
from src.models.model_manager import ModelManager
from src.data_processing.dataset_builder import DatasetBuilder
from src.models.recommendation_manager import RecommendationManager
from src.api.recommendation_api import RecommendationAPI
from src.utils.data_utils import format_currency_tnd, format_currency_tnd_business

# Configuration de la page
st.set_page_config(
    page_title="Tableau de Bord - Pr√©diction Bancaire",
    page_icon="üè¶",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Initialisation de l'√©tat de session
if 'prediction_model' not in st.session_state:
    st.session_state.prediction_model = None
if 'dataset' not in st.session_state:
    st.session_state.dataset = None
if 'model_manager' not in st.session_state:
    st.session_state.model_manager = ModelManager()
if 'recommendation_manager' not in st.session_state:
    st.session_state.recommendation_manager = RecommendationManager()
if 'recommendation_api' not in st.session_state:
    st.session_state.recommendation_api = RecommendationAPI()
if 'current_page' not in st.session_state:
    st.session_state.current_page = 'home'

def load_prediction_model():
    """Chargement du mod√®le de pr√©diction."""
    try:
        # Utiliser le ModelManager pour obtenir le mod√®le actif
        model_manager = ModelManager()
        active_model = model_manager.get_active_model()
        
        if active_model is not None:
            return active_model
        else:
            # V√©rifier l'ancien fichier prediction_model.json avec validation
            model_path = Path("data/models/prediction_model.json")
            if model_path.exists():
                # Validation de s√©curit√© du fichier mod√®le
                try:
                    import json
                    with open(model_path, 'r') as f:
                        model_data = json.load(f)
                    
                    # V√©rifications de base du mod√®le
                    if not isinstance(model_data, dict):
                        st.error("Format de mod√®le invalide")
                        return None
                    
                    required_fields = ['model_type', 'is_trained']
                    if not all(field in model_data for field in required_fields):
                        st.error("Mod√®le incomplet - champs requis manquants")
                        return None
                        
                    model = CheckPredictionModel()
                    model.load_model(str(model_path))
                    return model
                except json.JSONDecodeError:
                    st.error("Fichier mod√®le corrompu")
                    return None
            else:
                return None
    except Exception as e:
        st.error(f"√âchec du chargement du mod√®le: {e}")
        return None

def load_dataset():
    """Chargement du dataset trait√©."""
    try:
        dataset_path = Path("data/processed/dataset_final.csv")
        
        if dataset_path.exists():
            return pd.read_csv(dataset_path)
        else:
            st.warning("Dataset non trouv√©. Veuillez d'abord ex√©cuter le pipeline de traitement des donn√©es.")
            return None
    except Exception as e:
        st.error(f"√âchec du chargement du dataset: {e}")
        return None

def main():
    """Application principale du tableau de bord."""
    
    # En-t√™te
    st.title("üè¶ Syst√®me de Pr√©diction Bancaire - Intelligence Financi√®re")
    st.markdown("---")
    
    # Chargement du mod√®le et du dataset si pas d√©j√† charg√©s
    if st.session_state.prediction_model is None:
        with st.spinner("Chargement du mod√®le de pr√©diction..."):
            st.session_state.prediction_model = load_prediction_model()
    
    # V√©rifier aussi si on doit recharger depuis ModelManager (au cas o√π le mod√®le a √©t√© entra√Æn√©)
    if st.session_state.prediction_model is None:
        try:
            active_model = st.session_state.model_manager.get_active_model()
            if active_model is not None:
                st.session_state.prediction_model = active_model
        except Exception:
            pass
    
    if st.session_state.dataset is None:
        with st.spinner("Chargement du dataset..."):
            st.session_state.dataset = load_dataset()
    
    # Nouvelle navigation par blocs
    current_page = st.session_state.current_page
    
    if current_page == 'home':
        show_new_home_page()
    elif current_page == 'analytics':
        show_analytics_insights_page()
    elif current_page == 'models':
        show_models_management_page()
    elif current_page == 'predictions':
        show_unified_predictions_page()
    elif current_page == 'performance':
        show_performance_analysis_page()
    elif current_page == 'recommendations':
        show_unified_recommendations_page()
    elif current_page == 'simulation':
        show_client_simulation_page()

def show_new_home_page():
    """Nouvelle page d'accueil avec blocs de navigation cliquables."""
    
    st.header("üè† Tableau de Bord - Intelligence Bancaire")
    
    # M√©triques de vue d'ensemble du syst√®me
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            label="Statut du Mod√®le",
            value="‚úÖ Pr√™t" if st.session_state.prediction_model and st.session_state.prediction_model.is_trained else "‚ùå Non Pr√™t",
            delta="Mod√®le entra√Æn√©" if st.session_state.prediction_model and st.session_state.prediction_model.is_trained else "Entra√Ænement requis"
        )
    
    with col2:
        dataset_size = len(st.session_state.dataset) if st.session_state.dataset is not None else 0
        st.metric(
            label="Base de Donn√©es",
            value=f"{dataset_size:,}",
            delta="Clients"
        )
    
    with col3:
        st.metric(
            label="Pr√©cision Syst√®me",
            value="85-91%",
            delta="Performances ML"
        )
    
    with col4:
        st.metric(
            label="Services",
            value="8",
            delta="Alternatives Ch√®ques"
        )
    
    st.markdown("---")
    
    # Analyse des donn√©es int√©gr√©e (partie statique)
    show_integrated_data_insights()
    
    st.markdown("---")
    
    # Modules de navigation par blocs visuels
    st.subheader("üéõÔ∏è Modules du Syst√®me")
    st.markdown("Cliquez sur un module pour l'utiliser :")
    
    # Premi√®re ligne de modules
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üìä 1. Analyse des Donn√©es & Insights", use_container_width=True, type="primary"):
            st.session_state.current_page = 'analytics'
            st.rerun()
        st.markdown("""
        **üîç Explorez vos donn√©es**
        - Analyse comportementale des clients
        - Tendances de paiement
        - Insights m√©tier
        """)
    
    with col2:
        if st.button("‚öôÔ∏è 2. Gestion des Mod√®les", use_container_width=True, type="secondary"):
            st.session_state.current_page = 'models'
            st.rerun()
        st.markdown("""
        **ü§ñ G√©rez l'IA**
        - Entra√Æner de nouveaux mod√®les
        - Comparer les performances
        - Pipeline de donn√©es
        """)
    
    with col3:
        if st.button("üîÆ 3. Pr√©diction", use_container_width=True, type="secondary"):
            st.session_state.current_page = 'predictions'
            st.rerun()
        st.markdown("""
        **üéØ Pr√©disez l'avenir**
        - Nombre de ch√®ques clients
        - Montants maximums
        - Confiance des pr√©dictions
        """)
    
    # Deuxi√®me ligne de modules
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üìà 4. Performance des Mod√®les", use_container_width=True, type="secondary"):
            st.session_state.current_page = 'performance'
            st.rerun()
        st.markdown("""
        **üìä Analysez les performances**
        - M√©triques d√©taill√©es
        - Importance des variables
        - Comparaisons mod√®les
        """)
    
    with col2:
        if st.button("üéØ 5. Recommandations", use_container_width=True, type="secondary"):
            st.session_state.current_page = 'recommendations'
            st.rerun()
        st.markdown("""
        **üí° Recommandations intelligentes**
        - Services personnalis√©s
        - Analyse comportementale
        - ROI estim√©
        """)
    
    with col3:
        if st.button("üé≠ 6. Simulation Client / Actions", use_container_width=True, type="secondary"):
            st.session_state.current_page = 'simulation'
            st.rerun()
        st.markdown("""
        **üß™ Simulez et agissez**
        - Tests de sc√©narios
        - Suivi des adoptions
        - Actions commerciales
        """)

def show_integrated_data_insights():
    """Analyse des donn√©es int√©gr√©e dans la page d'accueil."""
    
    st.subheader("üìà Insights des Donn√©es - Vue d'Ensemble")
    
    if st.session_state.dataset is None:
        st.warning("‚ö†Ô∏è Donn√©es non disponibles. Veuillez ex√©cuter le pipeline de donn√©es.")
        return
        
    df = st.session_state.dataset
    
    # M√©triques principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_clients = len(df)
        st.metric("Total Clients", f"{total_clients:,}")
    
    with col2:
        avg_checks = df['Target_Nbr_Cheques_Futur'].mean()
        st.metric("Ch√®ques Moyens/Client", f"{avg_checks:.1f}")
        st.caption("üìù **Interpr√©tation:** Moyenne de ch√®ques pr√©dits par client pour l'ann√©e")
    
    with col3:
        avg_amount = df['Target_Montant_Max_Futur'].mean()
        st.metric("Montant Max Moyen", format_currency_tnd(avg_amount, 0))
        st.caption("üí∞ **Interpr√©tation:** Montant maximum moyen autoris√© par ch√®que")
    
    with col4:
        derogation_rate = df['A_Demande_Derogation'].mean() * 100
        st.metric("Taux de D√©rogation", f"{derogation_rate:.1f}%")
        st.caption("‚ö†Ô∏è **Interpr√©tation:** Pourcentage de clients ayant demand√© des d√©rogations")
    
    # Graphiques compacts avec interpr√©tations
    col1, col2 = st.columns(2)
    
    with col1:
        # Distribution par march√©
        market_counts = df['CLIENT_MARCHE'].value_counts()
        fig = px.pie(
            values=market_counts.values, 
            names=market_counts.index, 
            title="Distribution des Clients par March√©"
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üè¢ **Interpr√©tation:** R√©partition de la client√®le par segment de march√©")
    
    with col2:
        # Evolution comportementale
        fig = px.histogram(
            df,
            x='Ecart_Nbr_Cheques_2024_2025',
            title="√âvolution Usage des Ch√®ques (2024‚Üí2025)"
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üìä **Interpr√©tation:** Valeurs n√©gatives = r√©duction ch√®ques, positives = augmentation")

    # Bouton retour √† l'accueil sur toutes les pages non-home
    if st.session_state.current_page != 'home':
        st.markdown("---")
        if st.button("üè† Retour √† l'Accueil", type="secondary"):
            st.session_state.current_page = 'home'
            st.rerun()

def show_analytics_insights_page():
    """Page d'analyse des donn√©es et insights d√©taill√©s (one-page)."""
    
    st.header("üìä Analyse des Donn√©es & Insights D√©taill√©s")
    
    if st.session_state.dataset is None:
        st.error("Dataset non disponible. Veuillez v√©rifier le pipeline de traitement des donn√©es.")
        add_back_to_home_button()
        return
    
    df = st.session_state.dataset
    
    # Vue d'ensemble compacte
    st.subheader("üìà Vue d'Ensemble Compl√®te")
    
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.metric("Total Clients", f"{len(df):,}")
    with col2:
        avg_checks = df['Target_Nbr_Cheques_Futur'].mean()
        st.metric("Ch√®ques Moyens", f"{avg_checks:.1f}")
    with col3:
        avg_amount = df['Target_Montant_Max_Futur'].mean()
        st.metric("Montant Max Moyen", format_currency_tnd(avg_amount, 0))
    with col4:
        derogation_rate = df['A_Demande_Derogation'].mean() * 100
        st.metric("Taux D√©rogation", f"{derogation_rate:.1f}%")
    with col5:
        mobile_rate = df['Utilise_Mobile_Banking'].mean() * 100
        st.metric("Mobile Banking", f"{mobile_rate:.1f}%")
    
    # Analyses d√©taill√©es dans une seule vue
    col1, col2 = st.columns(2)
    
    with col1:
        # Distribution par march√©
        market_counts = df['CLIENT_MARCHE'].value_counts()
        fig = px.pie(values=market_counts.values, names=market_counts.index, 
                    title="üè¢ Distribution par March√© Client")
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üí° **Insight:** Particuliers dominent le portefeuille client")
        
        # CSP Analysis
        csp_counts = df['CSP'].value_counts().head(8)
        fig = px.bar(x=csp_counts.values, y=csp_counts.index, orientation='h',
                    title="üë• Top 8 Cat√©gories Socio-Professionnelles")
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üí° **Insight:** Salari√©s cadres repr√©sentent le segment principal")
    
    with col2:
        # Distribution des variables cibles
        fig = px.histogram(df, x='Target_Nbr_Cheques_Futur', 
                          title="üéØ Distribution Nombre de Ch√®ques Pr√©dit")
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üí° **Insight:** La plupart des clients utilisent 0-10 ch√®ques/an")
        
        # Montants
        fig = px.histogram(df, x='Target_Montant_Max_Futur', 
                          title="üí∞ Distribution Montant Maximum")
        st.plotly_chart(fig, use_container_width=True)
        st.caption(f"üí° **Insight:** Concentration autour de {format_currency_tnd(30000, 0)}-{format_currency_tnd(50000, 0)}")
    
    # Analyses comportementales
    st.subheader("üß† Analyses Comportementales")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Evolution 2024->2025
        fig = px.histogram(df, x='Ecart_Nbr_Cheques_2024_2025',
                          title="üìà √âvolution Usage Ch√®ques (2024‚Üí2025)")
        st.plotly_chart(fig, use_container_width=True)
        reduction_clients = len(df[df['Ecart_Nbr_Cheques_2024_2025'] < 0])
        st.caption(f"üí° **Insight:** {reduction_clients:,} clients r√©duisent leur usage des ch√®ques")
    
    with col2:
        # Mobile Banking vs Ch√®ques - Fixed to handle missing data
        mobile_vs_checks = df.groupby('Utilise_Mobile_Banking')['Target_Nbr_Cheques_Futur'].mean()
        
        # Ensure we have both categories, default to 0 if missing
        without_mobile = mobile_vs_checks.get(0, 0)
        with_mobile = mobile_vs_checks.get(1, 0)
        
        # Create the chart with proper data alignment
        x_labels = ['Sans Mobile Banking', 'Avec Mobile Banking']
        y_values = [without_mobile, with_mobile]
        
        fig = px.bar(x=x_labels, y=y_values,
                    title="üì± Mobile Banking vs Usage Ch√®ques")
        st.plotly_chart(fig, use_container_width=True)
        
        # Calculate reduction safely
        if without_mobile > 0 and with_mobile > 0:
            reduction = ((without_mobile - with_mobile) / without_mobile * 100)
            st.caption(f"üí° **Insight:** Mobile Banking r√©duit usage ch√®ques de {reduction:.1f}%")
        else:
            st.caption(f"üí° **Insight:** Donn√©es insuffisantes pour comparaison Mobile Banking")
    
    # Segments et revenus
    st.subheader("üíº Analyse Segments et Revenus")
    
    col1, col2 = st.columns(2)
    
    with col1:
        segment_counts = df['Segment_NMR'].value_counts()
        fig = px.bar(x=segment_counts.index, y=segment_counts.values,
                    title="üéØ R√©partition par Segment Client")
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üí° **Insight:** Segment Essentiel domine le portefeuille")
    
    with col2:
        # Corr√©lation revenus/ch√®ques
        fig = px.scatter(df, x='Revenu_Estime', y='Target_Nbr_Cheques_Futur',
                        color='CLIENT_MARCHE', title="üí∞ Revenus vs Usage Ch√®ques")
        st.plotly_chart(fig, use_container_width=True)
        st.caption("üí° **Insight:** Corr√©lation positive entre revenus et usage ch√®ques")
    
    add_back_to_home_button()

def show_models_management_page():
    """Page de gestion des mod√®les unifi√©e (one-page)."""
    
    st.header("‚öôÔ∏è Gestion Compl√®te des Mod√®les IA")
    
    model_manager = st.session_state.model_manager
    
    # Section statut actuel
    st.subheader("üìä Statut Actuel du Syst√®me")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        active_model = model_manager.get_active_model()
        st.metric("Mod√®le Actif", 
                 "‚úÖ Pr√™t" if active_model else "‚ùå Aucun",
                 "Entra√Æn√©" if active_model else "Requiert entra√Ænement")
    
    with col2:
        saved_models = model_manager.list_models()
        st.metric("Mod√®les Sauvegard√©s", len(saved_models))
    
    with col3:
        if active_model and hasattr(active_model, 'metrics'):
            metrics = active_model.metrics
            nbr_r2 = metrics.get('nbr_cheques', {}).get('r2', 0)
            st.metric("Pr√©cision Ch√®ques", f"{nbr_r2:.1%}")
        else:
            st.metric("Pr√©cision Ch√®ques", "N/A")
    
    with col4:
        if active_model and hasattr(active_model, 'metrics'):
            amount_r2 = metrics.get('montant_max', {}).get('r2', 0) 
            st.metric("Pr√©cision Montants", f"{amount_r2:.1%}")
        else:
            st.metric("Pr√©cision Montants", "N/A")
    
    # Entra√Ænement rapide
    st.subheader("üöÄ Entra√Ænement Rapide")
    
    col1, col2 = st.columns(2)
    
    with col1:
        model_options = {
            'gradient_boost': 'üöÄ Gradient Boosting (Recommand√©)',
            'linear': '‚ö° R√©gression Lin√©aire (Rapide)', 
            'neural_network': 'üß† R√©seau de Neurones (Avanc√©)'
        }
        
        selected_model = st.selectbox("Algorithme:", list(model_options.keys()), 
                                    format_func=lambda x: model_options[x])
    
    with col2:
        st.markdown("**Caract√©ristiques:**")
        if selected_model == 'gradient_boost':
            st.markdown("‚Ä¢ Meilleure pr√©cision (91%)")
            st.markdown("‚Ä¢ Temps d'entra√Ænement moyen")
            st.markdown("‚Ä¢ Recommand√© pour production")
        elif selected_model == 'linear':
            st.markdown("‚Ä¢ Pr√©cision correcte (85%)")
            st.markdown("‚Ä¢ Tr√®s rapide")
            st.markdown("‚Ä¢ Bon pour tests rapides")
        else:
            st.markdown("‚Ä¢ Pr√©cision variable (78%)")
            st.markdown("‚Ä¢ Plus lent")
            st.markdown("‚Ä¢ Exp√©rimental")
    
    if st.button("üéØ Entra√Æner Nouveau Mod√®le", type="primary", use_container_width=True):
        if st.session_state.dataset is not None:
            train_model_unified(selected_model)
        else:
            st.error("Dataset non disponible. Ex√©cutez d'abord le pipeline de donn√©es.")
    
    # Biblioth√®que des mod√®les dans une vue compacte
    st.subheader("üìö Biblioth√®que des Mod√®les")
    
    if saved_models:
        for model in saved_models:
            with st.expander(f"{'üéØ ACTIF' if model.get('is_active') else 'üì¶'} {model['model_name']} - {model.get('performance_summary', {}).get('overall_score', 'N/A')} pr√©cision"):
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.write(f"**Type:** {model['model_type']}")
                    st.write(f"**Cr√©√©:** {model['created_date'][:10]}")
                
                with col2:
                    if "performance_summary" in model:
                        perf = model["performance_summary"] 
                        st.write(f"**Ch√®ques:** {perf['checks_accuracy']}")
                        st.write(f"**Montants:** {perf['amount_accuracy']}")
                
                with col3:
                    if not model.get('is_active'):
                        if st.button("üéØ Activer", key=f"activate_{model['model_id']}"):
                            try:
                                model_manager.set_active_model(model['model_id'])
                                st.session_state.prediction_model = model_manager.get_active_model()
                                st.success("‚úÖ Mod√®le activ√©!")
                                st.rerun()
                            except Exception as e:
                                st.error(f"Erreur: {e}")
                    
                    if st.button("üóëÔ∏è Supprimer", key=f"delete_{model['model_id']}"):
                        try:
                            model_manager.delete_model(model['model_id'])
                            if model.get('is_active'):
                                st.session_state.prediction_model = None
                            st.success("üóëÔ∏è Mod√®le supprim√©!")
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erreur: {e}")
    else:
        st.info("üìù Aucun mod√®le sauvegard√©. Entra√Ænez votre premier mod√®le!")
    
    # Pipeline de donn√©es
    st.subheader("‚öôÔ∏è Pipeline de Donn√©es")
    
    pipeline_status = check_pipeline_status()
    
    col1, col2 = st.columns(2)
    
    with col1:
        if pipeline_status["completed"]:
            st.success(f"‚úÖ Pipeline termin√©: {pipeline_status['records']:,} clients")
        else:
            st.warning("‚ö†Ô∏è Pipeline non termin√©")
    
    with col2:
        if st.button("üîÑ Ex√©cuter Pipeline", type="secondary"):
            run_data_pipeline()
    
    add_back_to_home_button()

def show_unified_predictions_page():
    """Page de pr√©diction unifi√©e avec tous les d√©tails (one-page)."""
    
    st.header("üîÆ Pr√©dictions Client - Interface Unifi√©e Am√©lior√©e")
    
    if not st.session_state.prediction_model or not st.session_state.prediction_model.is_trained:
        st.error("‚ùå Mod√®le de pr√©diction non disponible. Entra√Ænez d'abord un mod√®le dans 'Gestion des Mod√®les'.")
        add_back_to_home_button()
        return
    
    # Importer les nouveaux outils
    try:
        from src.utils.field_explanations import FieldExplanationSystem
        from src.utils.prediction_testing import PredictionTestingSystem
        explanation_system = FieldExplanationSystem()
        testing_system = PredictionTestingSystem()
    except ImportError as e:
        st.warning(f"‚ö†Ô∏è Modules d'am√©lioration non disponibles: {e}")
        explanation_system = None
        testing_system = None
    
    # Informations sur le mod√®le actuel
    model_info = st.session_state.prediction_model.get_model_info()
    metrics = st.session_state.prediction_model.metrics
    
    st.subheader("ü§ñ Mod√®le Actuel")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        model_names = {'linear': 'R√©gression Lin√©aire', 'gradient_boost': 'Gradient Boosting', 'neural_network': 'R√©seau de Neurones'}
        st.metric("Type de Mod√®le", model_names.get(model_info.get('model_type', 'unknown'), 'Inconnu'))
    
    with col2:
        nbr_r2 = metrics.get('nbr_cheques', {}).get('r2', 0)
        st.metric("Pr√©cision Ch√®ques", f"{nbr_r2:.1%}")
    
    with col3:
        amount_r2 = metrics.get('montant_max', {}).get('r2', 0)
        st.metric("Pr√©cision Montants", f"{amount_r2:.1%}")
    
    with col4:
        avg_confidence = (nbr_r2 + amount_r2) / 2
        st.metric("Confiance Globale", f"{avg_confidence:.1%}")
    
    # Performance d√©taill√©e (bouton pour afficher)
    if st.button("üìä Voir Performance D√©taill√©e", type="secondary"):
        show_performance_details()
    
    # Section de test avec vrais clients
    if testing_system:
        st.subheader("üß™ Test avec Vrais Clients du Dataset")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            if st.button("üé≤ Client Al√©atoire", use_container_width=True):
                test_client = testing_system.get_random_test_client()
                if test_client:
                    st.session_state.test_client_data = test_client
        
        with col2:
            if st.button("üì± Client Digital", use_container_width=True):
                test_client = testing_system.get_test_client_by_profile("digital")
                if test_client:
                    st.session_state.test_client_data = test_client
        
        with col3:
            if st.button("üèõÔ∏è Client Traditionnel", use_container_width=True):
                test_client = testing_system.get_test_client_by_profile("traditional")
                if test_client:
                    st.session_state.test_client_data = test_client
        
        with col4:
            if st.button("üëë Client Premium", use_container_width=True):
                test_client = testing_system.get_test_client_by_profile("premium")
                if test_client:
                    st.session_state.test_client_data = test_client
        
        # Afficher le client de test s√©lectionn√©
        if hasattr(st.session_state, 'test_client_data') and st.session_state.test_client_data:
            test_client = st.session_state.test_client_data
            st.info("‚úÖ Client de test charg√© depuis le dataset r√©el")
            
            display_info = testing_system.get_client_display_info(test_client)
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.write(f"**ID:** {display_info['id']}")
                st.write(f"**March√©:** {display_info['marche']}")
            with col2:
                st.write(f"**Segment:** {display_info['segment']}")
                st.write(f"**Profil:** {display_info['profil']}")
            with col3:
                st.write(f"**Revenu:** {display_info['revenu']}")
                st.write(f"**Mobile Banking:** {display_info['mobile_banking']}")
            with col4:
                st.write(f"**Ch√®ques 2024:** {display_info['cheques_2024']}")
                st.write(f"**Max 2024:** {display_info['montant_max_2024']}")
            
            # Tester avec ce client
            if st.button("üîÆ Tester Pr√©diction avec ce Client", type="primary"):
                try:
                    result = st.session_state.prediction_model.predict(test_client)
                    
                    # Validation de pr√©cision si donn√©es target disponibles
                    if 'Target_Nbr_Cheques_Futur' in test_client or 'Target_Montant_Max_Futur' in test_client:
                        validation = testing_system.validate_prediction_accuracy(result, test_client)
                        
                        st.success("‚úÖ Pr√©diction et validation termin√©es!")
                        
                        # R√©sultats avec validation
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            st.metric(
                                "Nombre de Ch√®ques Pr√©dit", 
                                result['predicted_nbr_cheques'],
                                delta=f"R√©el: {test_client.get('Target_Nbr_Cheques_Futur', 'N/A')}"
                            )
                            nbr_validation = validation['nbr_cheques_validation']
                            st.write(f"{nbr_validation['status']} **{nbr_validation['level']}**")
                            st.caption(nbr_validation['interpretation'])
                        
                        with col2:
                            st.metric(
                                "Montant Maximum Pr√©dit",
                                format_currency_tnd(result['predicted_montant_max']),
                                delta=f"R√©el: {format_currency_tnd(test_client.get('Target_Montant_Max_Futur', 0))}"
                            )
                            montant_validation = validation['montant_max_validation']
                            st.write(f"{montant_validation['status']} **{montant_validation['level']}**")
                            st.caption(montant_validation['interpretation'])
                        
                        with col3:
                            overall = validation['overall_accuracy']
                            st.metric(
                                "Pr√©cision Globale",
                                f"{overall['score']:.1%}",
                                f"Niveau: {overall['level']}"
                            )
                            st.caption(overall['interpretation'])
                        
                        # Afficher les nouvelles m√©triques de confiance
                        if 'model_confidence' in result and isinstance(result['model_confidence'], dict):
                            confidence = result['model_confidence']
                            if 'confidence_level' in confidence:
                                st.subheader("üéØ Analyse de Confiance Avanc√©e")
                                
                                col1, col2, col3, col4 = st.columns(4)
                                with col1:
                                    st.metric("Niveau Confiance", confidence['confidence_level'])
                                with col2:
                                    st.metric("Confiance Globale", f"{confidence.get('overall_confidence', 0):.1%}")
                                with col3:
                                    st.metric("Qualit√© Donn√©es", f"{confidence.get('data_completeness_score', 0):.1%}")
                                with col4:
                                    st.metric("Coh√©rence Tendance", f"{confidence.get('trend_consistency_score', 0):.1%}")
                        
                        # Validation business
                        if 'business_validation' in result:
                            business = result['business_validation']
                            if business['validation_reason'] != "Aucun ajustement n√©cessaire":
                                st.info(f"üîß **Ajustements appliqu√©s:** {business['validation_reason']}")
                    
                    else:
                        st.success("‚úÖ Pr√©diction termin√©e (pas de donn√©es de validation)")
                        
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("Nombre de Ch√®ques Pr√©dit", result['predicted_nbr_cheques'])
                        with col2:
                            st.metric("Montant Maximum Pr√©dit", format_currency_tnd(result['predicted_montant_max']))
                        with col3:
                            confidence = result.get('model_confidence', {})
                            avg_conf = (confidence.get('nbr_cheques_r2', 0) + confidence.get('montant_max_r2', 0)) / 2
                            st.metric("Confiance Mod√®le", f"{avg_conf:.1%}")
                
                except Exception as e:
                    st.error(f"‚ùå Erreur lors du test: {e}")
        
        st.markdown("---")
    
    # Formulaire de pr√©diction unifi√© avec explications
    st.subheader("üë§ Nouvelle Pr√©diction Client avec Explications")
    
    with st.form("unified_prediction_form"):
        # Informations client sur 2 colonnes
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### üìã Profil Client")
            
            # Champ avec explication
            client_id = st.text_input("ID Client", value="client_pred_001", 
                                    help="Identifiant unique du client dans le syst√®me bancaire")
            
            # March√© avec tooltip d√©taill√©
            if explanation_system:
                marche_help = explanation_system.get_field_tooltip("CLIENT_MARCHE")
            else:
                marche_help = "Segment commercial du client"
            marche = st.selectbox("March√© Client", ["Particuliers", "PME", "TPE", "GEI", "TRE", "PRO"],
                                help=marche_help)
            
            csp = st.text_input("CSP (Cat√©gorie Socio-Professionnelle)", value="SALARIE CADRE MOYEN",
                              help="Profession du client (ex: SALARIE CADRE MOYEN, RETRAITE, etc.)")
            
            # Segment avec explication business
            if explanation_system:
                segment_help = explanation_system.get_field_tooltip("Segment_NMR")
            else:
                segment_help = "Segment de valeur client bas√© sur les revenus"
            segment = st.selectbox("Segment NMR", ["S1 Excellence", "S2 Premium", "S3 Essentiel", "S4 Avenir", "S5 Univers"],
                                 help=segment_help)
            
            secteur = st.text_input("Secteur d'Activit√©", value="ADMINISTRATION PUBLIQUE",
                                  help="Secteur d'activit√© professionnel du client")
        
        with col2:
            st.markdown("#### üí∞ Finances & Historique")
            
            # Revenu avec explication d√©taill√©e
            if explanation_system:
                revenu_help = explanation_system.get_field_tooltip("Revenu_Estime")
            else:
                revenu_help = "Revenu annuel estim√© en TND"
            revenu = st.number_input("Revenu Annuel Estim√© (TND)", min_value=0.0, value=50000.0,
                                   help=revenu_help)
            
            # Nombre ch√®ques avec contexte
            if explanation_system:
                nbr_help = explanation_system.get_field_tooltip("Nbr_Cheques_2024")
            else:
                nbr_help = "Nombre total de ch√®ques √©mis en 2024"
            nbr_2024 = st.number_input("Nombre de Ch√®ques 2024", min_value=0, value=5,
                                     help=nbr_help)
            
            # Montant avec validation business
            if explanation_system:
                montant_help = explanation_system.get_field_tooltip("Montant_Max_2024")
            else:
                montant_help = "Montant maximum d'un ch√®que en 2024"
            montant_2024 = st.number_input("Montant Maximum 2024 (TND)", min_value=0.0, value=30000.0,
                                         help=montant_help)
            
            nbr_transactions = st.number_input("Nombre Transactions 2025", min_value=1, value=20,
                                             help="Nombre total de transactions (tous types) en 2025")
            
            # Mobile banking avec impact
            if explanation_system:
                mobile_help = explanation_system.get_field_tooltip("Utilise_Mobile_Banking")
            else:
                mobile_help = "Le client utilise-t-il l'application mobile bancaire?"
            mobile_banking = st.checkbox("Utilise Mobile Banking", help=mobile_help)
        
        # Param√®tres avanc√©s avec explications
        st.markdown("#### ‚öôÔ∏è Param√®tres Comportementaux")
        col3, col4, col5 = st.columns(3)
        
        with col3:
            if explanation_system:
                derog_help = explanation_system.get_field_tooltip("A_Demande_Derogation")
            else:
                derog_help = "Client a-t-il demand√© une d√©rogation pour son ch√©quier?"
            demande_derogation = st.checkbox("A Demand√© D√©rogation", help=derog_help)
            
            if explanation_system:
                methodes_help = explanation_system.get_field_tooltip("Nombre_Methodes_Paiement")
            else:
                methodes_help = "Nombre de m√©thodes de paiement utilis√©es"
            nb_methodes = st.number_input("Nb M√©thodes Paiement", min_value=1, value=3, help=methodes_help)
        
        with col4:
            if explanation_system:
                ecart_help = explanation_system.get_field_tooltip("Ecart_Nbr_Cheques_2024_2025")
            else:
                ecart_help = "√âvolution du nombre de ch√®ques entre 2024 et 2025"
            ecart_cheques = st.number_input("√âcart Ch√®ques 2024‚Üí2025", value=-2, help=ecart_help)
            
            if explanation_system:
                ecart_montant_help = explanation_system.get_field_tooltip("Ecart_Montant_Max_2024_2025")
            else:
                ecart_montant_help = "√âvolution du montant maximum entre 2024 et 2025"
            ecart_montant = st.number_input("√âcart Montant Max (TND)", value=5000.0, help=ecart_montant_help)
        
        with col5:
            if explanation_system:
                ratio_help = explanation_system.get_field_tooltip("Ratio_Cheques_Paiements")
            else:
                ratio_help = "Proportion des paiements effectu√©s par ch√®ques (0.0 √† 1.0)"
            ratio_cheques = st.slider("Ratio Paiements Ch√®ques", 0.0, 1.0, 0.3, help=ratio_help)
            
            if explanation_system:
                moy_help = explanation_system.get_field_tooltip("Montant_Moyen_Cheque")
            else:
                moy_help = "Montant moyen des ch√®ques √©mis par le client"
            montant_moyen_cheque = st.number_input("Montant Moyen Ch√®que (TND)", value=1500.0, help=moy_help)
        
        # Guide d'aide rapide
        if explanation_system:
            with st.expander("üí° Guide d'Aide Rapide - Signification des Champs"):
                st.markdown("**Conseils pour une pr√©diction optimale:**")
                st.markdown("‚Ä¢ **Revenu Estim√©**: Influence directement les montants pr√©dits")
                st.markdown("‚Ä¢ **Mobile Banking**: Les clients digitaux utilisent g√©n√©ralement moins de ch√®ques")
                st.markdown("‚Ä¢ **Ratio Ch√®ques**: >0.5 = forte d√©pendance, <0.2 = usage minimal")
                st.markdown("‚Ä¢ **√âcart n√©gatif**: Indique une r√©duction de l'usage des ch√®ques")
                st.markdown("‚Ä¢ **Segment S1/S2**: Clients premium avec montants plus √©lev√©s")
        
        predict_button = st.form_submit_button("üîÆ PR√âDIRE", use_container_width=True, type="primary")
        
        if predict_button:
            # Pr√©parer les donn√©es
            client_data = {
                'CLI': client_id,
                'CLIENT_MARCHE': marche,
                'CSP': csp,
                'Segment_NMR': segment,
                'CLT_SECTEUR_ACTIVITE_LIB': secteur,
                'Revenu_Estime': revenu,
                'Nbr_Cheques_2024': nbr_2024,
                'Montant_Max_2024': montant_2024,
                'Nbr_Transactions_2025': nbr_transactions,
                'Ecart_Nbr_Cheques_2024_2025': ecart_cheques,
                'Ecart_Montant_Max_2024_2025': ecart_montant,
                'A_Demande_Derogation': int(demande_derogation),
                'Ratio_Cheques_Paiements': ratio_cheques,
                'Utilise_Mobile_Banking': int(mobile_banking),
                'Nombre_Methodes_Paiement': nb_methodes,
                'Montant_Moyen_Cheque': montant_moyen_cheque,
                'Montant_Moyen_Alternative': 800.0
            }
            
            # Effectuer la pr√©diction
            try:
                result = st.session_state.prediction_model.predict(client_data)
                
                # Affichage des r√©sultats avec validation am√©lior√©e
                st.success("‚úÖ Pr√©diction termin√©e avec succ√®s!")
                
                # R√©sultats principaux avec validation business
                st.subheader("üéØ R√©sultats de la Pr√©diction Valid√©e")
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric(
                        "Nombre de Ch√®ques Pr√©dit", 
                        result['predicted_nbr_cheques'],
                        delta=f"vs {nbr_2024} en 2024"
                    )
                    
                    # Afficher si la pr√©diction a √©t√© ajust√©e
                    if 'business_validation' in result:
                        if result['business_validation']['nbr_cheques_validated']:
                            st.caption("üîß Ajust√© par validation business")
                
                with col2:
                    st.metric(
                        "Montant Maximum Pr√©dit",
                        format_currency_tnd(result['predicted_montant_max']),
                        delta=f"vs {format_currency_tnd(montant_2024)} en 2024"
                    )
                    
                    # Afficher si le montant a √©t√© ajust√©
                    if 'business_validation' in result:
                        if result['business_validation']['montant_max_validated']:
                            st.caption("üîß Ajust√© par validation business")
                
                with col3:
                    # Utiliser la nouvelle confiance am√©lior√©e si disponible
                    confidence = result['model_confidence']
                    if 'overall_confidence' in confidence:
                        overall_conf = confidence['overall_confidence']
                        conf_level = confidence.get('confidence_level', 'MOYENNE')
                        st.metric(
                            "Confiance Globale",
                            f"{overall_conf:.1%}",
                            conf_level
                        )
                    else:
                        # Fallback sur l'ancienne m√©thode
                        avg_confidence = (confidence['nbr_cheques_r2'] + confidence['montant_max_r2']) / 2
                        st.metric(
                            "Confiance du Mod√®le",
                            f"{avg_confidence:.1%}",
                            "Score R¬≤ Moyen"
                        )
                
                # M√©triques de confiance d√©taill√©es
                if 'model_confidence' in result and 'confidence_level' in result['model_confidence']:
                    st.subheader("üìä Analyse de Confiance D√©taill√©e")
                    
                    confidence = result['model_confidence']
                    col1, col2, col3, col4 = st.columns(4)
                    
                    with col1:
                        st.metric(
                            "Qualit√© des Donn√©es",
                            f"{confidence.get('data_completeness_score', 0):.1%}",
                            "Compl√©tude"
                        )
                    
                    with col2:
                        st.metric(
                            "Coh√©rence Tendance",
                            f"{confidence.get('trend_consistency_score', 0):.1%}",
                            "Historique"
                        )
                    
                    with col3:
                        st.metric(
                            "Logique Business",
                            f"{confidence.get('business_logic_score', 0):.1%}",
                            "Validation"
                        )
                    
                    with col4:
                        level = confidence.get('confidence_level', 'MOYENNE')
                        color = {'TR√àS √âLEV√âE': 'üü¢', '√âLEV√âE': 'üîµ', 'MOYENNE': 'üü°', 'FAIBLE': 'üü†', 'TR√àS FAIBLE': 'üî¥'}
                        st.metric(
                            "Niveau Global",
                            f"{color.get(level, '‚ö™')} {level}",
                            "√âvaluation"
                        )
                
                # Validation et ajustements appliqu√©s
                if 'business_validation' in result:
                    validation = result['business_validation']
                    if validation['validation_reason'] != "Aucun ajustement n√©cessaire":
                        st.info(f"üîß **Ajustements automatiques appliqu√©s:** {validation['validation_reason']}")
                    
                    # Afficher les valeurs brutes vs ajust√©es si diff√©rentes
                    if 'raw_predictions' in result:
                        raw = result['raw_predictions']
                        if (raw['nbr_cheques_raw'] != result['predicted_nbr_cheques'] or 
                            raw['montant_max_raw'] != result['predicted_montant_max']):
                            
                            with st.expander("üîç Comparaison Pr√©dictions Brutes vs Valid√©es"):
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.write("**Nombre de Ch√®ques:**")
                                    st.write(f"‚Ä¢ Brute: {raw['nbr_cheques_raw']:.1f}")
                                    st.write(f"‚Ä¢ Valid√©e: {result['predicted_nbr_cheques']}")
                                with col2:
                                    st.write("**Montant Maximum:**")
                                    st.write(f"‚Ä¢ Brut: {format_currency_tnd(raw['montant_max_raw'])}")
                                    st.write(f"‚Ä¢ Valid√©: {format_currency_tnd(result['predicted_montant_max'])}")
                
                # Analyse compl√©mentaire
                st.subheader("üß† Analyse Compl√©mentaire")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    # Impact pr√©diction
                    evolution_checks = result['predicted_nbr_cheques'] - nbr_2024
                    if evolution_checks > 0:
                        st.warning(f"‚¨ÜÔ∏è **Augmentation pr√©vue:** +{evolution_checks} ch√®ques")
                        st.markdown("üí° **Recommandation:** Proposer alternatives digitales")
                    elif evolution_checks < 0:
                        st.success(f"‚¨áÔ∏è **R√©duction pr√©vue:** {evolution_checks} ch√®ques")
                        st.markdown("üí° **Opportunit√©:** Client en transition digitale")
                    else:
                        st.info("‚û°Ô∏è **Stabilit√© pr√©vue:** Usage constant")
                
                with col2:
                    # Cat√©gorisation du client
                    if result['predicted_nbr_cheques'] <= 5:
                        st.success("üü¢ **Client Digital** - Usage minimal des ch√®ques")
                    elif result['predicted_nbr_cheques'] <= 15:
                        st.info("üü° **Client Mixte** - Usage mod√©r√© des ch√®ques") 
                    else:
                        st.warning("üî¥ **Client Traditionnel** - Usage √©lev√© des ch√®ques")
                
                # D√©tails techniques (expandable) - S√âCURIS√â
                with st.expander("üîß D√©tails Techniques"):
                    # Afficher uniquement les m√©triques non-sensibles
                    safe_details = {
                        "modele_utilise": result.get('model_info', {}).get('model_type', 'N/A'),
                        "confiance_prediction": f"{result.get('confidence', 0):.1%}",
                        "timestamp": result.get('prediction_timestamp', 'N/A'),
                        "version_modele": result.get('model_info', {}).get('version', 'N/A')
                    }
                    st.json(safe_details)
                
            except Exception as e:
                st.error(f"‚ùå √âchec de la pr√©diction: {e}")
    
    add_back_to_home_button()

def show_performance_analysis_page():
    """Page d'analyse des performances des mod√®les (one-page)."""
    
    st.header("üìà Analyse des Performances - Vue Compl√®te")
    
    if not st.session_state.prediction_model or not st.session_state.prediction_model.is_trained:
        st.error("Mod√®le non disponible. Veuillez v√©rifier la gestion des mod√®les.")
        add_back_to_home_button()
        return
    
    show_performance_details()
    add_back_to_home_button()

def show_unified_recommendations_page():
    """Page de recommandations unifi√©e (one-page)."""
    
    st.header("üéØ Recommandations Personnalis√©es - Interface Compl√®te")
    
    # Section principale de recommandation
    st.subheader("üí° G√©n√©rer Recommandations Client")
    
    # Mode de saisie
    input_mode = st.radio("Mode de saisie:", 
                         ["üìã Client Existant", "‚úèÔ∏è Nouveau Client"], horizontal=True)
    
    if input_mode == "üìã Client Existant":
        if st.session_state.dataset is not None:
            client_ids = st.session_state.dataset['CLI'].unique()
            selected_client = st.selectbox("S√©lectionnez un client:", client_ids)
            
            if st.button("üéØ G√©n√©rer Recommandations", type="primary"):
                generate_and_display_recommendations(selected_client, mode="existing")
        else:
            st.warning("‚ö†Ô∏è Dataset non disponible.")
    
    else:  # Nouveau client
        with st.form("recommendation_form"):
            col1, col2, col3 = st.columns(3)
            
            with col1:
                client_id = st.text_input("ID Client", value="nouveau_001")
                marche = st.selectbox("March√©", ["Particuliers", "PME", "TPE"])
                csp = st.text_input("CSP", value="SALARIE CADRE MOYEN")
                revenu = st.number_input("Revenu (TND)", value=50000.0)
            
            with col2:
                segment = st.selectbox("Segment", ["S1 Excellence", "S2 Premium", "S3 Essentiel"])
                nbr_cheques_2024 = st.number_input("Ch√®ques 2024", value=5)
                mobile_banking = st.checkbox("Mobile Banking")
                nb_methodes = st.number_input("Nb M√©thodes Paiement", value=3)
            
            with col3:
                secteur = st.text_input("Secteur", value="SERVICES")
                montant_max_2024 = st.number_input("Montant Max 2024", value=30000.0)
                demande_derogation = st.checkbox("Demande D√©rogation")
                ecart_cheques = st.number_input("√âcart Ch√®ques", value=-2)
            
            if st.form_submit_button("üéØ G√©n√©rer Recommandations", use_container_width=True):
                manual_data = {
                    'CLI': client_id, 'CLIENT_MARCHE': marche, 'CSP': csp, 'Segment_NMR': segment,
                    'CLT_SECTEUR_ACTIVITE_LIB': secteur, 'Revenu_Estime': revenu,
                    'Nbr_Cheques_2024': nbr_cheques_2024, 'Montant_Max_2024': montant_max_2024,
                    'Nbr_Transactions_2025': 20, 'Ecart_Nbr_Cheques_2024_2025': ecart_cheques,
                    'Ecart_Montant_Max_2024_2025': 5000.0, 'A_Demande_Derogation': int(demande_derogation),
                    'Utilise_Mobile_Banking': int(mobile_banking), 'Nombre_Methodes_Paiement': nb_methodes,
                    'Ratio_Cheques_Paiements': 0.3
                }
                generate_and_display_recommendations(manual_data, mode="manual")
    
    # Analyse par segments (compacte)
    st.subheader("üìä Analyse par Segments Comportementaux")
    
    segments_info = {
        "TRADITIONNEL_RESISTANT": {"clients": "~15%", "services": ["Formation Digital", "Accompagnement Personnel"]},
        "TRADITIONNEL_MODERE": {"clients": "~25%", "services": ["Carte Bancaire", "Virements Auto"]},
        "DIGITAL_TRANSITOIRE": {"clients": "~30%", "services": ["Mobile Banking", "Paiement QR"]},
        "DIGITAL_ADOPTER": {"clients": "~20%", "services": ["Services Premium", "Carte Premium"]},
        "DIGITAL_NATIF": {"clients": "~8%", "services": ["Pack Premium", "Solutions Avanc√©es"]},
        "EQUILIBRE": {"clients": "~2%", "services": ["Mix Optimal", "Services √âquilibr√©s"]}
    }
    
    col1, col2, col3 = st.columns(3)
    
    for i, (segment, info) in enumerate(segments_info.items()):
        with [col1, col2, col3][i % 3]:
            with st.expander(f"{segment} - {info['clients']}"):
                st.write("**Services recommand√©s:**")
                for service in info['services']:
                    st.write(f"‚Ä¢ {service}")
    
    # Catalogue des services (compact)
    st.subheader("üíº Catalogue des Services")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**üÜì Services Gratuits:**")
        free_services = ["Carte Bancaire Moderne", "Mobile Banking", "Virements Auto", "Paiement QR", "Formation Digital"]
        for service in free_services:
            st.write(f"‚Ä¢ {service}")
    
    with col2:
        st.markdown("**üíé Services Premium:**")
        st.write(f"‚Ä¢ Carte Sans Contact Premium ({format_currency_tnd_business(150, 'service_cost')}/an)")
        st.write(f"‚Ä¢ Pack Services Premium ({format_currency_tnd_business(600, 'service_cost')}/an)")
    
    add_back_to_home_button()

def show_client_simulation_page():
    """Page de simulation client et actions (one-page)."""
    
    st.header("üé≠ Simulation Client & Actions Commerciales")
    
    st.subheader("üß™ Simulateur de Sc√©narios")
    
    # Tests rapides de sc√©narios
    scenario_type = st.selectbox("Type de simulation:", 
                                ["üìà Impact Mobile Banking", "üí≥ Adoption Carte Premium", "üîÑ Migration Digitale"])
    
    if scenario_type == "üìà Impact Mobile Banking":
        st.info("**Sc√©nario:** Client traditionnel adoptant mobile banking")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Avant Mobile Banking", "12 ch√®ques/an")
            st.metric("Co√ªt Traitement", f"{format_currency_tnd_business(54, 'service_cost')}/an")
        
        with col2:
            st.metric("Apr√®s Mobile Banking", "6 ch√®ques/an (-50%)")
            st.metric("√âconomies", f"{format_currency_tnd_business(27, 'service_cost')}/an")
        
        st.success("üí° **Insight:** Mobile banking divise par 2 l'usage des ch√®ques")
    
    # Suivi des adoptions (simulation)
    st.subheader("üìä Suivi des Adoptions")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Recommandations G√©n√©r√©es", "1,247")
    with col2:
        st.metric("Adoptions Confirm√©es", "421")
    with col3:
        st.metric("Taux d'Adoption", "33.8%")
    with col4:
        st.metric("ROI Estim√©", format_currency_tnd_business(156400, 'impact'))
    
    # Actions commerciales sugg√©r√©es
    st.subheader("üéØ Actions Commerciales Sugg√©r√©es")
    
    actions = [
        {"priorit√©": "üî¥ HAUTE", "action": "Campagne Mobile Banking", "cible": "Clients +10 ch√®ques/an", "impact": "R√©duction 40% usage"},
        {"priorit√©": "üü° MOYENNE", "action": "Promotion Carte Premium", "cible": f"Revenus >{format_currency_tnd(80000, 0)}", "impact": f"Revenus +{format_currency_tnd_business(150, 'revenue')}/client/an"},
        {"priorit√©": "üü¢ BASSE", "action": "Formation Digital Senior", "cible": "Clients 65+ ans", "impact": "Adoption graduelle"}
    ]
    
    for action in actions:
        with st.expander(f"{action['priorit√©']} - {action['action']}"):
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Cible:** {action['cible']}")
            with col2:
                st.write(f"**Impact attendu:** {action['impact']}")
    
    # Tableau de bord commercial
    st.subheader("üìà Tableau de Bord Commercial")
    
    # Graphique simul√©
    import numpy as np
    dates = pd.date_range('2024-01-01', periods=12, freq='M')
    adoptions = np.random.poisson(35, 12).cumsum()
    
    fig = px.line(x=dates, y=adoptions, title="√âvolution Adoptions Services 2024")
    fig.update_layout(height=300)
    st.plotly_chart(fig, use_container_width=True)
    
    add_back_to_home_button()

def add_back_to_home_button():
    """Ajoute un bouton de retour √† l'accueil."""
    st.markdown("---")
    if st.button("üè† Retour √† l'Accueil", type="secondary"):
        st.session_state.current_page = 'home'
        st.rerun()

def train_model_unified(model_type):
    """Entra√Ænement de mod√®le unifi√© avec feedback temps r√©el."""
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    try:
        status_text.text("üìä Pr√©paration des donn√©es...")
        progress_bar.progress(20)
        
        training_data = st.session_state.dataset.to_dict('records')
        
        status_text.text(f"ü§ñ Entra√Ænement {model_type}...")
        progress_bar.progress(40)
        
        model = CheckPredictionModel()
        model.set_model_type(model_type)
        model.fit(training_data)
        
        status_text.text("üíæ Sauvegarde...")
        progress_bar.progress(80)
        
        model_manager = st.session_state.model_manager
        model_id = model_manager.save_model(model)
        model_manager.set_active_model(model_id)
        st.session_state.prediction_model = model_manager.get_active_model()
        
        progress_bar.progress(100)
        status_text.text("‚úÖ Termin√©!")
        
        st.success("üéâ Mod√®le entra√Æn√© et activ√© avec succ√®s!")
        
        # Afficher les m√©triques
        if hasattr(model, 'metrics'):
            col1, col2 = st.columns(2)
            with col1:
                nbr_r2 = model.metrics.get('nbr_cheques', {}).get('r2', 0)
                st.metric("Pr√©cision Ch√®ques", f"{nbr_r2:.1%}")
            with col2:
                amount_r2 = model.metrics.get('montant_max', {}).get('r2', 0)
                st.metric("Pr√©cision Montants", f"{amount_r2:.1%}")
        
    except Exception as e:
        st.error(f"‚ùå Erreur d'entra√Ænement: {e}")

def show_performance_details():
    """Affiche les d√©tails de performance du mod√®le."""
    metrics = st.session_state.prediction_model.metrics
    
    st.markdown("### üìä M√©triques D√©taill√©es")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üî¢ Mod√®le Nombre de Ch√®ques")
        nbr_metrics = metrics.get('nbr_cheques', {})
        
        subcol1, subcol2 = st.columns(2)
        with subcol1:
            st.metric("R¬≤ Score", f"{nbr_metrics.get('r2', 0):.4f}")
            st.metric("MAE", f"{nbr_metrics.get('mae', 0):.2f}")
        with subcol2:
            st.metric("MSE", f"{nbr_metrics.get('mse', 0):.2f}")
            st.metric("RMSE", f"{nbr_metrics.get('rmse', 0):.2f}")
    
    with col2:
        st.markdown("#### üí∞ Mod√®le Montant Maximum")
        montant_metrics = metrics.get('montant_max', {})
        
        subcol1, subcol2 = st.columns(2)
        with subcol1:
            st.metric("R¬≤ Score", f"{montant_metrics.get('r2', 0):.4f}")
            st.metric("MAE", f"{montant_metrics.get('mae', 0):,.0f}")
        with subcol2:
            st.metric("MSE", f"{montant_metrics.get('mse', 0):,.0f}")
            st.metric("RMSE", f"{montant_metrics.get('rmse', 0):,.0f}")
    
    # Importance des variables
    importance = st.session_state.prediction_model.get_feature_importance()
    if importance:
        st.markdown("### üéØ Importance des Variables")
        
        importance_df = pd.DataFrame(
            list(importance.items()),
            columns=['Variable', 'Importance']
        ).sort_values('Importance', ascending=True)
        
        fig = px.bar(importance_df, x='Importance', y='Variable', orientation='h',
                    title="Variables les Plus Influentes")
        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)

def generate_and_display_recommendations(client_data, mode="existing"):
    """G√©n√®re et affiche les recommandations."""
    with st.spinner("G√©n√©ration des recommandations..."):
        try:
            if mode == "existing":
                recommendations = st.session_state.recommendation_api.get_client_recommendations(client_data)
            else:
                recommendations = st.session_state.recommendation_api.get_manual_client_recommendations(client_data)
            
            if recommendations.get('status') == 'success':
                rec_data = recommendations['data']
                
                # Profil comportemental
                st.subheader("üß† Profil Comportemental")
                
                behavior_profile = rec_data.get('behavior_profile', {})
                
                # V√©rifier si segmentation avanc√©e pour afficher plus d'informations
                if 'behavioral_scores' in behavior_profile:
                    col1, col2, col3, col4, col5 = st.columns(5)
                else:
                    col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    segment = behavior_profile.get('behavior_segment', 'N/A')
                    
                    # Ajouter des indicateurs visuels coh√©rents
                    segment_icons = {
                        'TRADITIONNEL_RESISTANT': 'üî¥',
                        'TRADITIONNEL_MODERE': 'üü°', 
                        'DIGITAL_TRANSITOIRE': 'üü†',
                        'DIGITAL_ADOPTER': 'üü¢',
                        'DIGITAL_NATIF': 'üíö',
                        'EQUILIBRE_MIXTE': 'üîµ'
                    }
                    
                    icon = segment_icons.get(segment, '‚ö™')
                    st.metric("Segment", f"{icon} {segment}")
                    
                    # Afficher la logique de classification
                    if segment == 'TRADITIONNEL_RESISTANT' and 'behavioral_scores' in behavior_profile:
                        check_val = behavior_profile['behavioral_scores'].get('check_dependency_score', 0)
                        digital_val = behavior_profile['behavioral_scores'].get('digital_adoption_score', 0)
                        if check_val > 0.6 and digital_val < 0.3:
                            st.caption("‚úÖ Logique coh√©rente")
                        else:
                            st.caption("‚ö†Ô∏è V√©rifier logique")
                    elif segment == 'TRADITIONNEL_MODERE' and 'behavioral_scores' in behavior_profile:
                        check_val = behavior_profile['behavioral_scores'].get('check_dependency_score', 0)
                        digital_val = behavior_profile['behavioral_scores'].get('digital_adoption_score', 0)
                        if (0.25 <= check_val <= 0.65) and (0.25 <= digital_val <= 0.65):
                            st.caption("‚úÖ Logique coh√©rente")
                        else:
                            st.caption("‚ö†Ô∏è V√©rifier logique")
                
                with col2:
                    # V√©rifier si on utilise la segmentation avanc√©e (scores dans behavioral_scores)
                    if 'behavioral_scores' in behavior_profile:
                        check_score = behavior_profile['behavioral_scores'].get('check_dependency_score', 0) * 100
                    else:
                        # Syst√®me legacy (scores au niveau racine)
                        check_score = behavior_profile.get('check_dependency_score', 0) * 100
                    st.metric("D√©pendance Ch√®ques", f"{check_score:.1f}%")
                
                with col3:
                    if 'behavioral_scores' in behavior_profile:
                        digital_score = behavior_profile['behavioral_scores'].get('digital_adoption_score', 0) * 100
                    else:
                        digital_score = behavior_profile.get('digital_adoption_score', 0) * 100
                    st.metric("Adoption Digitale", f"{digital_score:.1f}%")
                
                with col4:
                    if 'behavioral_scores' in behavior_profile:
                        evolution_score = behavior_profile['behavioral_scores'].get('payment_evolution_score', 0) * 100
                    else:
                        evolution_score = behavior_profile.get('payment_evolution_score', 0) * 100
                    st.metric("√âvolution Paiements", f"{evolution_score:.1f}%")
                
                # Afficher le score de modernit√© si segmentation avanc√©e
                if 'behavioral_scores' in behavior_profile:
                    with col5:
                        modernity_score = behavior_profile['behavioral_scores'].get('modernity_score', 0) * 100
                        st.metric("Score Modernit√©", f"{modernity_score:.1f}%")
                
                # Afficher la confiance d'analyse avec contexte
                if 'confidence' in behavior_profile:
                    confidence = behavior_profile['confidence'] * 100
                    if confidence >= 80:
                        st.success(f"üéØ Analyse tr√®s fiable: {confidence:.1f}%")
                    elif confidence >= 60:
                        st.info(f"üéØ Analyse fiable: {confidence:.1f}%")
                    else:
                        st.warning(f"‚ö†Ô∏è Analyse √† confirmer: {confidence:.1f}% - Donn√©es incompl√®tes")
                
                # Ajouter une explication du segment pour l'utilisateur
                if 'behavioral_scores' in behavior_profile:
                    segment = behavior_profile.get('behavior_segment', 'N/A')
                    segment_explanations = {
                        'TRADITIONNEL_RESISTANT': 'üî¥ Client tr√®s d√©pendant aux ch√®ques, r√©sistant au digital',
                        'TRADITIONNEL_MODERE': 'üü° Client mod√©r√©ment traditionnel, ouvert au changement',
                        'DIGITAL_TRANSITOIRE': 'üü† Client en transition active vers le digital',
                        'DIGITAL_ADOPTER': 'üü¢ Client adopteur avanc√© des services digitaux',
                        'DIGITAL_NATIF': 'üíö Client natif digital, avant-gardiste',
                        'EQUILIBRE_MIXTE': 'üîµ Client avec approche √©quilibr√©e et flexible'
                    }
                    
                    explanation = segment_explanations.get(segment, '')
                    if explanation:
                        st.markdown(f"**üìù Profil:** {explanation}")
                
                # Recommandations avec organisation claire
                st.subheader("üéØ Services Recommand√©s")
                
                recommendations = rec_data.get('recommendations', [])
                if not recommendations:
                    st.warning("Aucune recommandation disponible pour ce profil.")
                else:
                    st.markdown(f"**{len(recommendations)} service(s) recommand√©(s)** pour ce profil client")
                    
                    for i, rec in enumerate(recommendations):
                        service_info = rec.get('service_info', {})
                        scores = rec.get('scores', {})
                        
                        # Priorit√© visuelle selon le score
                        score = scores.get('global', 0)
                        if score >= 0.8:
                            priority_icon = "üèÜ"  # Tr√®s recommand√©
                        elif score >= 0.6:
                            priority_icon = "‚≠ê"  # Recommand√©
                        else:
                            priority_icon = "üí°"  # √Ä consid√©rer
                        
                        with st.expander(f"{priority_icon} #{i+1} {service_info.get('nom', 'Service')} - Score: {score:.2f}/1.0"):
                            col1, col2 = st.columns(2)
                        
                            with col1:
                                st.write(f"**üìã Description:** {service_info.get('description', 'N/A')}")
                                st.write(f"**üéØ Objectif:** {service_info.get('cible', 'N/A')}")
                                st.write(f"**üí∞ Co√ªt:** {format_currency_tnd(service_info.get('cout', 0), 0)}")
                                st.write(f"**üè∑Ô∏è Type:** {service_info.get('type', 'Service Bancaire')}")
                                
                                # Lien vers le produit Attijari Bank
                                product_link = service_info.get('lien_produit', '')
                                if product_link:
                                    st.markdown(f"**üîó [Acc√©der au service sur Attijari Bank]({product_link})**")
                                
                                # Avantages du service
                                avantages = service_info.get('avantages', [])
                                if avantages:
                                    st.write("**‚ú® Avantages:**")
                                    for avantage in avantages:
                                        st.write(f"‚Ä¢ {avantage}")
                        
                            with col2:
                                st.metric("üìä Score Base", f"{scores.get('base', 0):.2f}")
                                st.metric("‚ö° Score Urgence", f"{scores.get('urgency', 0):.2f}")
                                st.metric("‚úÖ Score Faisabilit√©", f"{scores.get('feasibility', 0):.2f}")
                
                # Impact estim√©
                st.subheader("üìà Impact Estim√©")
                
                impact = rec_data.get('impact_estimations', {})
                
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    reduction = impact.get('reduction_cheques_estimee', 0)
                    st.metric("R√©duction Ch√®ques", f"{reduction:.1f}")
                
                with col2:
                    percentage = impact.get('pourcentage_reduction', 0)
                    st.metric("% R√©duction", f"{percentage:.1f}%")
                
                with col3:
                    benefit = impact.get('benefice_bancaire_estime', 0)
                    st.metric("B√©n√©fice Estim√©", format_currency_tnd(benefit))
            
            else:
                st.error(f"Erreur: {recommendations.get('error', 'Erreur inconnue')}")
        
        except Exception as e:
            st.error(f"Erreur lors de la g√©n√©ration: {e}")

# Anciennes fonctions supprim√©es - remplac√©es par les versions unifi√©es

# Anciennes fonctions supprim√©es - remplac√©es par les nouvelles versions unifi√©es one-page

# Toutes les anciennes fonctions ont √©t√© supprim√©es et remplac√©es par les nouvelles versions unifi√©es one-page

def check_pipeline_status():
    """V√©rifier le statut du pipeline de traitement des donn√©es."""
    try:
        dataset_path = Path("data/processed/dataset_final.csv")
        stats_path = Path("data/processed/dataset_statistics.json")
        
        if dataset_path.exists() and stats_path.exists():
            # Charger les statistiques
            with open(stats_path, 'r') as f:
                stats = json.load(f)
            
            return {
                "completed": True,
                "records": stats.get("dataset_overview", {}).get("total_clients", 0),
                "features": stats.get("dataset_overview", {}).get("total_features", 0),
                "files": len(list(Path("data/processed").glob("*.csv"))) + len(list(Path("data/processed").glob("*.json"))),
                "last_run": dataset_path.stat().st_mtime
            }
        else:
            return {"completed": False}
    except Exception:
        return {"completed": False}

def run_data_pipeline():
    """Ex√©cuter le pipeline complet de traitement des donn√©es."""
    with st.spinner("Ex√©cution du pipeline complet de traitement des donn√©es..."):
        try:
            builder = DatasetBuilder()
            final_dataset = builder.run_complete_pipeline()
            st.session_state.dataset = pd.DataFrame(final_dataset)
            st.success("‚úÖ Pipeline de donn√©es termin√© avec succ√®s!")
            st.info(f"üìä Le dataset contient {len(final_dataset):,} enregistrements clients")
            st.rerun()
        except Exception as e:
            st.error(f"‚ùå √âchec du pipeline: {e}")

def show_data_statistics():
    """Afficher les statistiques d√©taill√©es des donn√©es."""
    try:
        stats_path = Path("data/processed/dataset_statistics.json")
        if stats_path.exists():
            with open(stats_path, 'r') as f:
                stats = json.load(f)
            
            st.json(stats)
        else:
            st.warning("Fichier de statistiques non trouv√©")
    except Exception as e:
        st.error(f"√âchec du chargement des statistiques: {e}")

# Toutes les anciennes fonctions de recommandations ont √©t√© remplac√©es par les nouvelles versions unifi√©es

if __name__ == "__main__":
    main()